
Déclaration de la caméra:

	camera {
		lookat <vecteur> 
		eye <vecteur>
		up <vecteur>
	}
	
Création d'un objet:

object [Nom de l'objet] {
	material <Déclaration matériau OU use 'référence matériau'>
	geometry <Déclaration géométrie OU use 'référence géométrie'>
	instance <Modèle>
	rotate <Vecteur> <Angle>
	translate <Vecteur>
}

renderer {
	progressive 
	bidirectional
}

camera {
	eye <>
	lookat <>
}

mesh cornellbox {
	vertices {
		<0.0 0.0 0.0>
		<0.0 0.0 0.0>
	}
	triangleset {
		material lambertian uni <0.8 0.8 0.8>
		tri 1 2 3
		tri 3 4 8
		tri 8 4 1
	}
	triangleset {
		material anisotropic nu 100 nv 1000 texture uni <0.7 0.7 0.2>
		tri ...
		tri ...
		tri ...
	}
}

plane P center <0.0 -1.0 0.0> normal <0.0 1.0 0.0>
sphere lightsource 
	center <0.0 0.0 0.0> 
	radius 0.7 
	emittance <4.0 4.0 4.0> 
	material null
	
sphere testsphere center <3.0 0.0 0.0> radius 1.0 material anisotropic nu 100 nv 1000 texture checkerboard <...> <...>
ambient envmap hdr "uffizi-large.hdr" scale 1.75
renderer pathtracing depth 6 progressive
image size <640 480>
camera eye <> lookat <> up <> size auto

instance box rotate <> material ...


// TODO: box, cylinder primitives

sphere testsphere radius 

sphere lightsource 
	radius 0.7
	material null
	emittance <4.0 4.0 4.0>


ambient color <0.1 0.1 0.1>


defmaterial gold phong 

defmaterial(x) gold phong exp (x) color <...>

object test_sphere {
	material {
		glass 
		refr 1.1
	}
	geometry { 
		sphere
		radius 1.0 
	}
	texture { checkerboard COLOR_WHITE COLOR_LIGHTGREEN }
	translate <0.0 0.0 -1.0>
}

geometry {
	indexed triangle mesh
	vertices <...>  
	indices <...>
	normals <...>
}

geometry {
	mesh 
	import <filename>
}

Création d'un matériau

material [Nom du matériau] {
	glass {
		refr <Indice de réfraction>
	}

	mirror {

	}

	schlick {
		R0
	}

	color <couleur OU déclaration texture OU use 'référence couleur' OU use 'référence texture' 
}

texture {
	checkerboard <vecteur couleur 1> <vecteur couleur 2>
}

camera {
	lookat <0.0 0.0 0.0> eye <0.0 0.0 0.0> up <0.0 0.0 1.0>
}

object obj {
	sphere {
		radius 1.0
	}
	rotate deg 90
	color hsv <0.0 0.0 0.0>
	material mat
}

sphere C radius 1.0 texture uni <0.0 0.0 1.0> material lambertian 
	

colorvalue: vec3 | 'hsv' vec3 | 'rgb' vec3
vec3: '<' float float float '>'
vec4: '<' float float float float '>'

material_decl: 'material' material_block
material_block: '{' material_decls '}' | material_decls '\n'
material_decls: 'lambertian' lbparams


TODO:
Lecture d'un fichier de description
Ray tracer sans illumination globale
Gestion des transformations
Gestion des textures
Gestion des modèles de réflections

bsdf.h

class BSDF

/*
 * Sample: Génère une nouvelle direction pour le tracé de rayon
 * et retourne la réflectance au point d'intersection
 *
 * 
 */

 MultiBSDF: N BSDFs at random with a probability distribution
 
 
PreviewRenderer
 - drawSphere(center, radius)
 - drawPlane(Plane)
 - renderMesh(Mesh)
 
Renderer module:
 - RenderTask.stop
 - RenderTask.restart
 
SceneEditor module:
 * Edition mode
 - Editor.pickObject -> ObjectEditor
 - Editor.getScene -> new Scene
 - Editor.getSelected
 - Editor.disable
 - Editor.enable
 
UI module:
 * UI elements and layout
 - UI(Window)
 - UI.draw
 - UI.onClick
 - UI.onClickRender
 - UI.onClickStop
 - UI.drawSlider
 - UI.drawButton
 - UI.onResize
 - UI.eventHandler
 
 - UIContainer.render(GLContext)
 - UIContainer.add
 - UIContainer.remove
 - UIContainer.setLayout
 - UIContainer.setBackground
 
 - UIElement.setHandler
 
Window module:
 * OpenGL context
 * Result image
 - begin2D -> 2D renderer
 - draw(sf::Text)
 - draw(sf::Rect)
 - end2D
 - begin3D -> (OpenGL calls)
 - end3D
 - updateImage(Image) 
 - updateCamera
 - onSceneUpdate
 - onResize
 - resize
 - onClick

Scene module:
 - Scene.addObject
 - Scene.deleteObject
 - Scene.findIntersection
 - Scene.getCamera
 
Camera module:
 - setEye
 - setCenter
 - getTransform

Primitive interface:
 - sample
 - getMaterial
 - setMaterial
 - previewRender(PreviewRenderer)
 
Material interface:
 - sampleTexture
 - getBSDF
 
global mode:
- editing
- rendering

 
 